# Про помилки роботи з пам’яттю в Linux та засоби їх усунення

---
## Завдання 1: Демонстрація проблеми циклічних посилань
### Опис
Ця програма показує, як циклічні посилання в динамічній структурі даних заважають звільнити пам’ять, створюючи витоки в пам'яті.

### Пояснення функціоналу програми
Програма створює два об’єкти, a і b, де a посилається на b, а b посилається на a. Кожен об’єкт має лічильник (refcount), який показує, скільки інших вказівників його утримує. Пам’ять звільняється лише тоді, коли лічильник стає 0.
#### Створення об’єктів:
Об’єкт a створюється з refcount = 1 (бо його утримує змінна a).
Об’єкт b створюється з refcount = 1 (бо його утримує змінна b).
#### Створення циклу:
a встановлює b як партнера (a->partner = b), і b->refcount стає 2 (від змінної b і від a).
b встановлює a як партнера (b->partner = a), і a->refcount стає 2 (від змінної a і від b).
#### Спроба звільнення:
Ми "відпускаємо" зовнішні змінні: rc_release(a) зменшує a->refcount до 1 (бо b все ще посилається на a).
rc_release(b) зменшує b->refcount до 1 (бо a все ще посилається на b).
Обидва об’єкти залишаються в пам’яті, бо їхні лічильники не 0.

### Чому пам’ять не звільняється?
Об’єкт a не може бути звільнений, бо b на нього посилається (b->partner = a).
Об’єкт b не може бути звільнений, бо a на нього посилається (a->partner = b).
Кожен об’єкт "тримає" іншого, і їхні лічильники (refcount) ніколи не стають 0. Без нульового лічильника пам’ять не звільняється, і ми отримуємо витік пам’яті.

### Перевірка витоків з Valgrind:
'''bash
valgrind --leak-check=full ./task1
'''

Вивід:
'''
Created two objects with cyclic references
==1232==
==1232== HEAP SUMMARY:
==1232==     in use at exit: 4,128 bytes in 3 blocks
==1232==   total heap usage: 3 allocs, 0 frees, 4,128 bytes allocated
==1232==
==1232== 32 (16 direct, 16 indirect) bytes in 1 blocks are definitely lost in loss record 2 of 3
==1232==    at 0x484E2E4: malloc (vg_replace_malloc.c:450)
==1232==    by 0x4006F3: rc_new (task1.c:11)
==1232==    by 0x4007CA: main (task1.c:42)
==1232==
==1232== LEAK SUMMARY:
==1232==    definitely lost: 16 bytes in 1 blocks
==1232==    indirectly lost: 16 bytes in 1 blocks
==1232==      possibly lost: 0 bytes in 0 blocks
==1232==    still reachable: 0 bytes in 0 blocks
==1232==         suppressed: 4,096 bytes in 1 blocks
'''

Два об’єкти (a і b) по 16 байт залишилися в пам’яті.
Жоден не був звільнений, бо їхні лічильники не досягли 0.
Якщо не вирішити цю проблему, пам’ять накопичується, і програма з часом стає все більш неефетивною.

### Як вирішити проблему:
Для вирішення потрібні спеціальні механізми, такі як:
- Слабкі посилання (не збільшують refcount).
- Збирання сміття для виявлення циклів.
- Ручне розривання циклів (нереалістичне в складних системах).

### Висновок
Цей код показує, як циклічні посилання створюють парадокс: об’єкти не можуть бути звільнені, бо кожен утримує іншого. Це призводить до витоку пам’яті, що є серйозною проблемою в програмах із динамічними структурами.
