# Про помилки роботи з пам’яттю в Linux та засоби їх усунення

---
## Завдання 1: Демонстрація проблеми циклічних посилань
### Опис
У цьому завданні ми демонструємо проблему витоків пам'яті через циклічні посилання у структурах даних на мові C. Циклічні посилання створюють ситуації, коли звільнення частини структури призводить до втрати доступу до інших її частин, що робить неможливим звільнення всієї виділеної пам'яті.

### Теоретичне підґрунтя
Циклічні посилання виникають, коли дві або більше структур даних містять вказівники одна на одну, утворюючи замкнутий цикл. У мовах програмування без автоматичного збирання сміття (як C) це створює складнощі при звільненні пам'яті.

Основна проблема полягає в тому, що звільнення одного елемента з циклу може призвести до втрати доступу до інших елементів, що залишилися в циклі, оскільки єдиний шлях до них проходив через елемент, який вже звільнили.

### Реалізація та демонстрація проблеми

У нашій програмі:
1. Створюється циклічна структура з трьох вузлів: `first -> second -> third -> first`
2. Програма отримує вказівник тільки на перший вузол, без прямого доступу до інших
3. При звільненні першого вузла, другий і третій стають недоступними, але залишаються в пам'яті
4. Через втрату вказівників на ці вузли, їх неможливо звільнити стандартними засобами C

### Результати виконання
```bash
# Компіляція програми
gcc -g -o task1 task1.c

# Запуск програми з Valgrind для аналізу витоків пам'яті
valgrind --leak-check=full ./task1
```

Результат виконання:
```
==1143==
==1143== HEAP SUMMARY:
==1143==     in use at exit: 4,128 bytes in 3 blocks
==1143==   total heap usage: 4 allocs, 1 frees, 4,144 bytes allocated
==1143==
==1143== 32 (16 direct, 16 indirect) bytes in 1 blocks are definitely lost in loss record 2 of 3
==1143==    at 0x484E2E4: malloc (vg_replace_malloc.c:450)
==1143==    by 0x400671: createCyclicStructure (task1.c:14)
==1143==    by 0x40075E: main (task1.c:53)
==1143==
==1143== LEAK SUMMARY:
==1143==    definitely lost: 16 bytes in 1 blocks
==1143==    indirectly lost: 16 bytes in 1 blocks
==1143==      possibly lost: 0 bytes in 0 blocks
==1143==    still reachable: 0 bytes in 0 blocks
==1143==         suppressed: 4,096 bytes in 1 blocks
==1143==
==1143== For lists of detected and suppressed errors, rerun with: -s
==1143== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
```

### Пояснення результатів

1. **Типи витоків пам'яті**:
   - **definitely lost (16 байт)**: Це другий вузол, до якого більше немає жодного вказівника після звільнення першого вузла.
   - **indirectly lost (16 байт)**: Це третій вузол, який доступний тільки через другий вузол, який сам вже недоступний.

2. **Аналіз витоків**:
   - `total heap usage: 4 allocs, 1 frees` показує, що з чотирьох алокацій звільнена лише одна.
   - Рядок `by 0x400671: createCyclicStructure (task1.c:14)` вказує, де саме відбулась алокація пам'яті, що призвела до витоку.

3. **Причина неуникненого витоку**: Після звільнення першого вузла через `free(startNode)` ми зберігаємо вказівник на другий вузол (`next`), але:
   - Якщо ми звільнимо другий вузол через `free(next)`, то втратимо доступ до третього вузла
   - Третій вузол залишиться в пам'яті без можливості його звільнити
   - Ми не маємо механізму для проходження через весь цикл після руйнування його структури

### Висновки

1. **Неуникненність витоків в циклічних структурах**: У мові C немає вбудованого механізму для автоматичного виявлення та звільнення всіх частин циклічної структури даних.

2. **Необхідність спеціальних підходів**: Для ефективного управління пам'яттю в програмах з циклічними структурами даних необхідно:
   - Підтримувати окремий перелік усіх створених об'єктів
   - Реалізувати алгоритми трасування для виявлення всіх зв'язків між об'єктами
   - Розривати цикли перед звільненням пам'яті

3. **Важливість інструментів діагностики**: Інструменти на зразок Valgrind є необхідними для виявлення витоків пам'яті, особливо тих, що виникають через складні структури з циклічними посиланнями.

4. **Порівняння з іншими мовами**: У мовах з автоматичним збиранням сміття (Java, Python, C#) проблема вирішується за допомогою алгоритмів, які виявляють недосяжні об'єкти та циклічні структури, що дозволяє автоматично звільняти таку пам'ять.
